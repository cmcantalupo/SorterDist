#include "partition.hpp"
#include "sorter_threaded_exception.hpp"

namespace SorterThreadedHelper {
 
  Partition::Partition(const std::set<double>& pivots) :
    numTasks_(pivots.size()+1),
    curTask_(0) {
    // A partition is generated by a set of pivots

    // We will create a map between PartitionWalls and their associated stack.  
    std::pair<PartitionWall,std::stack<double>*> pp;
    for (std::set<double>::iterator it = pivots.begin(); it != pivots.end(); ++it) {
      pp.first = PartitionWall::PartitionWall(*it,false);
      pp.second = new std::stack<double>;
      partition_.insert(pp);
    }

    // We need an extra PartitionWall for values that are greater than all the pivots.
    pp.first = PartitionWall::PartitionWall(*pivots.begin(), true);
    pp.second = new std::stack<double>;
    partition_.insert(pp);
    
    // curTaskIt_ keeps track of the next task to be popped by popTask()
    curTaskIt_ = partition_.begin();
  }

  Partition::~Partition() {
    // Delete all the stacks
    for (std::map<PartitionWall,std::stack<double>*>::iterator it = partition_.begin(); 
         it != partition_.end(); ++it) {
      delete it->second;
    }
  }

  Partition::Partition(const Partition& other) : 
    numTasks_(other.numTasks_), 
    curTask_(other.curTask_) {
    // Basic copy constructor.  
    std::pair<PartitionWall,std::stack<double>*> pp;

    size_t i = 0;
    for (std::map<PartitionWall,std::stack<double>*>::const_iterator it = other.partition_.begin(); 
         it != other.partition_.end(); ++it) {
      pp.first = it->first;
      pp.second = new std::stack<double>(*it->second);
      partition_.insert(pp);
      if( i == curTask_ ) {
        curTaskIt_ = partition_.find(it->first);
      }
      ++i;
    }
  }     

  void Partition::fill(std::vector<double>::const_iterator chunkBegin,
                       std::vector<double>::const_iterator chunkEnd) {
    // Fills the stacks of the partition from the chunk
    std::map<PartitionWall,std::stack<double>*>::iterator ub;
    for (std::vector<double>::const_iterator it = chunkBegin;
         it != chunkEnd; ++it) {
      ub = partition_.upper_bound(PartitionWall::PartitionWall(*it,false));
      // If we go off the end use the extra stack added to end.  
      if (ub == partition_.end()) --ub;
      ub->second->push(*it);
    }
  }

  void Partition::popTask(std::vector<double>::iterator begin, 
                          std::vector<double>::iterator end) {
    // Fills the input vector with all of the values stored 
    // in the stack pointed to by curTaskIt_;
    if (curTaskIt_ == partition_.end()) {
      throw(SorterThreadedException::PopEmptyPartition);
    }

    std::vector<double>::iterator it(begin);
    while (!curTaskIt_->second->empty()) {
      // Throw an exception if we get to the end iterator before we
      // pop the entire stack.
      if (it == end) {
        throw(SorterThreadedException::TaskTooLong);
      }
      *it = curTaskIt_->second->top();
      curTaskIt_->second->pop();
      ++it;
    }
    // Throw an exception if we didn't fill the entire range 
    // of the output.  
    if (it != end) {
      throw(SorterThreadedException::TaskTooShort);
    }
    // Increment the task iterator.  
    ++curTaskIt_;
    ++curTask_;
    if (curTaskIt_ == partition_.end()) {
      curTaskIt_ = partition_.begin();
      curTask_ = 0;
    }
  }

  size_t Partition::numTasks() {
    return numTasks_;
  }
  
  size_t Partition::curTask() {
    return curTask_;
  }

  size_t Partition::curSize() {
    return curTaskIt_->second->size();
  }

  void Partition::taskSizes(std::vector<size_t> &sizes) {
    // Fills a vector with the sizes of all the task stacks.
    sizes.resize(numTasks_);
    std::vector<size_t>::iterator sizeIt = sizes.begin();  
    for (std::map<PartitionWall,std::stack<double>*>::iterator taskIt = partition_.begin();
         taskIt != partition_.end(); ++taskIt, ++sizeIt) {
      *sizeIt = taskIt->second->size();
    }
  }

}
